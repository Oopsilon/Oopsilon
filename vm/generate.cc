#include <cassert>
#include <iostream>

#include "analyse.hh"
#include "ast.hh"
#include "generate.hh"

void
generateScopeName(Scope *scope, std::string &name)
{
	if (scope->kind == Scope::kMethod)
		name.insert(0, "M");
	else if (scope->kind == Scope::kBlock)
		name.insert(0, "B");
	if (scope->outerScope != NULL)
		return generateScopeName(scope->outerScope, name);
}

bool
useCrossesBlock(Scope *useScope, Scope *defScope)
{
	while (useScope != defScope) {
		/* does this work for optimised blocks??? i think it does? */
		if (useScope->kind == Scope::kBlock)
			return true;
		useScope = useScope->outerScope;
		assert(useScope != NULL);
	}
	return false;
}

std::string &
CodeGeneratorVisitor::nameForScope(Scope *scope)
{
	if (scopeNames.find(scope) == scopeNames.end()) {
		std::string name;
		generateScopeName(scope, name);
		scopeNames[scope] = std::move(name);
	}
	return scopeNames[scope];
}

std::string
CodeGeneratorVisitor::heapvarsNameForScope(Scope *scope)
{
	return nameForScope(scope) + "_heapvars";
}

void
CodeGeneratorVisitor::genHeapvarsType(CodeScope *scope)
{
	if (!scope->heapvars.empty()) {
		types << "struct " << heapvarsNameForScope(scope) << " {\n";
		for (auto &heapvar : scope->heapvars)
			types << "  oop " << heapvar.name << ";\n";
		types << "};\n\n";
	}
}

void
CodeGeneratorVisitor::genMoveArgumentsToHeapvars(CodeScope *scope,
    std::stringstream &stream)
{
	for (auto &arg : scope->arguments)
		if (arg.remoteAccess == Variable::kWrittenRemotely) {
			stream << heapvarsNameForScope(scope) << "->";
			emitVariableAccess(scope, &arg, stream);
			stream << " = ";
			emitVariableAccess(scope, &arg, stream);
			stream << ";\n";
		}
}

void
CodeGeneratorVisitor::visitClass(AST::ClassNode *node)
{
	std::cout << "Visiting class called " << node->m_name << "\n";
	AST::Visitor::visitClass(node);
}

void
CodeGeneratorVisitor::visitMethod(AST::MethodNode *node)
{
	std::cout << "Visiting method called " << node->m_selector << "\n";

	genHeapvarsType(node->scope);

	/* method body */
	scope.push(node->scope);
	funStack.push({});
	std::cout << "void method()\n{\n";
	genMoveArgumentsToHeapvars(node->scope, fun());
	AST::Visitor::visitMethod(node);
	std::cout << "}\n";
	funcs.push_back(fun().str());
	funStack.pop();
	scope.pop();

	std::cout
	    << "/*\n * generated by the Valutron Optimizing Compiler\n */\n";
	std::cout << types.str() << "\n";
	for (auto &fun : funcs)
		std::cout << fun << "\n";
}

void
CodeGeneratorVisitor::visitReturnStmt(AST::ReturnStmtNode *node)
{
	std::cout << "Visiting return stmt\n";
	/* need to handle block return case?? */
	fun() << "return ";
	AST::Visitor::visitReturnStmt(node);
	fun() << ";\n";
}

void
CodeGeneratorVisitor::visitBlockLocalReturn(AST::ExprNode *node)
{
	std::cout << "Visiting block local return stmt\n";
	if (!scope.top()->inOptimisedBlock())
		fun() << "return ";
	AST::Visitor::visitBlockLocalReturn(node);
	fun() << ";\n";
}

void
CodeGeneratorVisitor::visitExprStmt(AST::ExprStmtNode *node)
{
	AST::Visitor::visitExprStmt(node);
	fun() << ";\n";
}

void
CodeGeneratorVisitor::visitBlockExpr(AST::BlockExprNode *node)
{
	std::cout << "Visiting block expression:\n";
	genHeapvarsType(node->scope);

	/* block type */
	types << "struct block" << (intptr_t)node << "{\n";
	types << "/* heapvars */\n";
	for (auto &scope : node->scope->usingHeapvarsFrom)
		types << "  oop " << nameForScope(scope) << "_heapvars;\n";
	types << "/* copied vars */\n";
	for (auto &var : node->scope->copyingVars)
		types << "  oop " << nameForScope(var->scope) << var->name
		      << ";\n";
	types << "};\n\n";

	/* block context type */

	/* the function to make the block */
	types << "makeBlock" << (intptr_t)node << "(oop self";
	/* heapvar structs */
	for (auto &scope : node->scope->usingHeapvarsFrom)
		types << ", struct " << heapvarsNameForScope(scope) << " "
		      << heapvarsNameForScope(scope);
	/* copied variables*/
	for (auto &var : node->scope->copyingVars)
		types << ", oop " << nameForScope(var->scope) << var->name;
	types << ")\n{\n}\n\n";

	/* block code */
	funStack.push({});
	scope.push(node->scope);
	fun() << "static void block" << (uintptr_t)node << "()\n{\n";
	genMoveArgumentsToHeapvars(node->scope, fun());
	AST::Visitor::visitBlockExpr(node);
	fun() << "}\n";
	funcs.push_back(fun().str());
	scope.pop();
	funStack.pop();

	/* invocation of the makeBlock function */
	fun() << "makeBlock" << (uintptr_t)node << "(self";
	for (auto &aScope : node->scope->usingHeapvarsFrom) {
		fun() << ", ";
		if (useCrossesBlock(scope.top(), aScope))
			fun() << "thisBlock->";
		fun() << heapvarsNameForScope(aScope);
	}
	/* copied variables*/
	for (auto &var : node->scope->copyingVars) {
		fun() << ", ";
		emitVariableAccess(scope.top(), var, fun());
	}
	fun() << ")";
}

void
CodeGeneratorVisitor::visitInlinedBlockExpr(AST::BlockExprNode *node)
{
	std::cout << "Visiting inlined block expression:\n";
	/* block code */
	scope.push(node->scope);
	fun() << "({\n";
	AST::Visitor::visitBlockExpr(node);
	fun() << "})";
	scope.pop();
}

void
CodeGeneratorVisitor::visitMessageExpr(AST::MessageExprNode *node)
{
	std::cout << "Visiting message expression #" << node->selector << "\n";

	if (node->specialKind == AST::MessageExprNode::kIfTrueIfFalse) {
		fun() << "(";
		node->receiver->accept(*this);
		fun() << " ?\n    ";
		node->args[0]->accept(*this);
		fun() << " :\n    ";
		node->args[1]->accept(*this);
		fun() << ")";
		return;
	}

plain:
	fun() << "msgLookup(";
	node->receiver->accept(*this);
	fun() << ", \"" << node->selector << "\")";
	fun() << "(";
	bool first = true;
	for (auto &arg : node->args) {
		if (first)
			first = false;
		else
			fun() << ", ";
		arg->accept(*this);
	}
	fun() << ")";
}

void
CodeGeneratorVisitor::visitAssignExpr(AST::AssignExprNode *node)
{
	node->left->accept(*this);
	fun() << " = ";
	node->right->accept(*this);
}

void
CodeGeneratorVisitor::emitVariableAccess(Scope *scope, Variable *var,
    std::stringstream &stream)
{
	switch (var->kind) {
	case Variable::kArgument:
	case Variable::kLocal:
	case Variable::kHeapvar: {
		if (useCrossesBlock(scope, var->scope))
			stream << "thisBlock->";

		if (var->kind == Variable::kHeapvar)
			stream << heapvarsNameForScope(var->scope) << "->";

		stream << nameForScope(var->scope) << var->name;
		return;
	}
	case Variable::kInlinedBlockLocal:
		return emitVariableAccess(scope, var->real, stream);
	}
}

void
CodeGeneratorVisitor::visitIdentExpr(AST::IdentExprNode *node)
{
	std::cout << "Visiting identifier expression <" << node->id << ">\n";
	emitVariableAccess(scope.top(), node->variable, fun());
}

void
CodeGeneratorVisitor::visitIntExpr(AST::IntExprNode *node)
{
	std::cout << "Visiting integer literal " << node->num << "\n";
	fun() << "makeSMI(" << node->num << ")";
}
